# Python 对象

## 4-1 与所有Python对象有关的三个属性是什么？请简述
* 身份：每一个对象都有一个唯一的身份标识自己，且都可以用内建函数id()来得到
* 类型：对象的类型决定了该对象可以保持什么类型的值，可以进行什么操作，已经遵循什么样的规则
* 值：对象表示的数据项

## 4-2 不可更改指的是什么？Python中的哪些类型是可更改的，哪些不是？
某些类型允许对他们的值进行更新，而有些类型则不能对他们的值进行更新，不能更新自己值的类型就是不可更改的，该类型的对象称为不可变对象。<br>
可更改的类型有列表和字典，不可更改的有数字、字符串和元组。

## 4-3 哪些Python类型是按照顺序访问的，他们和映射类型的不同是什么？
字符串、列表和元组类型是按照顺序访问的，他们是采用下标索引顺序访问，下标从0开始。而映射虽然也是使用索引，但是采用的不是顺序的数字偏移量，而是通过一个唯一的键来访问，构成键-值对的集合，而这个键可以不止是数学类型，还可以是其他多种类型。

## 4-4 内建函数type()做什么？type()返回的对象是什么？
type(\*)会返回\*的类型。<br>
type()返回的对象，首先这个对象是一个对象，而这个对象有它的类型，它的类型就是type(这里type不是前面的那个函数名，而是一种类型的名字，与int，list等相同).<br>
简短的说就是：type()返回的对象的类型就是类型(注意这两个类型的不同含义)。

## 4-5 内建函数str()与repr()之间的不同是什么？哪一个等价于反引号(``)操作符？
repr()返回的是一个对象的“官方”字符串表示，即从编程语言的角度考虑，它所返回的这个字符串表示可以通过求值运算eval()重新得到该对象，即能返回去。
str()返回的也是一个对象的字符串表示，而是它返回的字符串通常不能通过eval()求值，但很适合用于print的输出。<br>
所以repr()输出对Python比较友好，因为从Python语言的角度看它可以用eval()运算反向得到对象；而str()的输出对用户友好，因为它返回的字符串表示适合用print输出，和用户能有更好的交互。<br>
repr()与反引号操作符等价。

## 4-6 你认为type(a)==type(b)和type(a) is type(b)之间的不同是什么？为什么会选择后者？函数isinstance()与这有什么关系？
type(a)与type(b)分别返回的是两个对象，
* ==是比较这两个对象的值是否相等。
* is是比较这两个对象的身份是否相等，即是否是同一个对象。

其实这两种方式完成的都是比较a和b的类型是否一样，只不过在type(a)和type(b)拿
到a和b的类型对象A，B之后，再判断A和B是不是一样的时候采用不同的方式，一是采用
判断A的值与B的值是否一样，二是采用判断A和B是不是同一个对象(或者说判断A和B是
不是同一个对象的不同引用)。<br>
选择后者的好处是基于这样一个事实：如果A和B不是同一个对象，那么的值也就不一
样。所以在知道A和B不是同一个对象的情况下，也就得到结论了，也没必要用==去根据
值判断，而在知道A和B是同一个对象的情况下，也没有必要再去用==了，故==就是没有
必要，用is即可。(只是说没有必要用==，而不是说用==不对，只不过用is效率更高)<br><br>
<i>有没有可能a和b都是int类型的，A和B也是对应int类型的类型对象，但是A和B对应
int的两个不同的对象，所以<b>导致a和b虽然都是int的，但是A和B却不是同一个对象
</b>，进一步导致type(a) is type(b)返回错误的结果？答案是否定的，因为每个类
型只有一个类型变量，所以前面加粗的部分所述情况是不会出现的</i>


## 4-8 列表和元组的相同点是什么？不同点是什么？
列表和元组都是Python中基本标准类型，它们都是类型，却属于不同的类型。<br>
相同点：从存储模型看，都是容器存储；从访问模型看，都属于顺序访问。
不同点：从更新模型看，列表属于可更改的，元组属于不可更改的。

## 4-9 *实践

```
>>> a=10
>>> b=10
>>> c=100
>>> d=100
>>> e=10.0
>>> f=10.0
>>> a is b
True
>>> c is d
True
>>> e is f
False
```

整型和字符串对象是不可变对象，所以Python会很高效第缓存它们。<br>
所以a=10，a是对象10的一个引用，接着b=10，Python不会为b新建一个对象10，然后
用a=10缓存的的对象，所以a和b指向了相同的对象，所以a is b会返回True。c is d
同理。<br>
由于浮点数类型不是有这样的缓存机制，所以e和f虽然都等于10.0，但却是不同的对
象，故返回False。<br>
需要了解这种特性，但提倡不要使用这个特性。<br>
具体见课本*P63 核心笔记：实践*
